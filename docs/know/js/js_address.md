--- 
title: js中数据的地址引用
date: 2021-06-10 08:46:25
author: 'Mr.Lan'
sidebar: 'auto'
categories: 
 - 前端
tags: 
 - js
 - 数据结构
 - 堆栈
publish: true
autoGroup-1: js问题
---
::: danger 问题描述
在js中复杂数据（对象，数组）的等号赋值方式都是将其地址引用，这样在实际运用中有时能带来一定的好处（缺点占大多）

可以利用这一特点建立同步数据，动一处则全动，可是在对元数据更新上会产生地址变动，原引用失效的问题
:::
<!-- more -->
## **1.问题描述**
先创建一个简单引用的环境
``` js
let a={
    a1:{
        a11:1
    }
}
let b=a.a1
```
这种情况下修改`b.a11`的值和`a.a1.a11`是一样的效果，
`b`与`a.a1`都是引用了`{a11:1}`这个对象的地址

把`b`赋值给另外一个对象中的属性
``` js
let c={
    c1:b
}
```
`a.a1`、`b`、 `c.c1`三者都是同一个地址

这时候就建立了一种我们想要的联系，动一处则全动，但也带来个问题

`a`是根源数据，我们想对`a`进行更新，只能遍历对其中的普通数据赋值

``` js
// 不会断开连接的更新方式
a.a1.a11=2
// 会与原来的引用断开连接
a={
    a1:{
        a11:2
    }
}
```
第一种的赋值方式能够保证`a.a1`、`b`、 `c.c1`三者还是引用同一个地址，它们三者的`a11`都是2

而第二种方式，将a引用至另外一个对象的地址，`b`、 `c.c1`中的`a11`依旧是1

这样就是失去了我们原来想要效果，并且第二种就是我们请求后台新数据的常用方式，问题就此产生出

地址的引用在平常很常见，例如常见的等号、对象中再次引用、数组`push`对象、形参传递等

以上对对象的操作都是地址的引用

***
## **2.思路**

一个复杂的对象并不知存在一级，多级对象存在多个地址的引用

为了不改变源数据的地址只对其中的简单数据（数字、Boolean、字符串等）更新

这样能达到想要的同步刷新的效果

解决方案以目前的知识量来看的话，递归遍历，和更新数据进行匹配，有不相同的基础数据，更新掉

## **3.问题**
date：2021-06-15 19:12:11

讨论发现上述方案虽然能够不改地址更新数据，但是对于新数据删除了某个整体对象这种情况

数据源能够删除对删除目标的引用，可在其他地方的引用并不会改变，这样并不是销毁了那个删除的对象

在js中对于堆中对象的销毁，只有没有任何栈变量引用的时候，gc会自动销毁

::: danger 错误警告
因此想利用js的地址引用形成数据同步更新本就不是个合理的操作

[vue](https://cn.vuejs.org/)的话应该使用[VueX](https://vuex.vuejs.org/zh/)进行管理数据
::: right
[VueX管理数据](../vue/vuex_guan_li_shu_ju.md)
:::